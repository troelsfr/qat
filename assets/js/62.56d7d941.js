(window.webpackJsonp=window.webpackJsonp||[]).push([[62],{446:function(e,t,a){"use strict";a.r(t);var n=a(54),s=Object(n.a)({},(function(){var e=this,t=e.$createElement,a=e._self._c||t;return a("ContentSlotsDistributor",{attrs:{"slot-key":e.$parent.slotKey}},[a("h1",{attrs:{id:"creating-a-profile-transformation-in-c"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#creating-a-profile-transformation-in-c"}},[e._v("#")]),e._v(" Creating a profile transformation in C++")]),e._v(" "),a("h2",{attrs:{id:"profile-transformation-as-pass"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#profile-transformation-as-pass"}},[e._v("#")]),e._v(" Profile transformation as pass")]),e._v(" "),a("p",[e._v("As an example of how one can implement a new profile pass, we here show the implementation details of our example pass which allows mapping the teleportation code to the base profile:")]),e._v(" "),a("div",{staticClass:"language-c++ extra-class"},[a("pre",{pre:!0,attrs:{class:"language-text"}},[a("code",[e._v('        pb.registerPipelineParsingCallback([](StringRef name, FunctionPassManager &fpm,\n                                              ArrayRef<PassBuilder::PipelineElement> /*unused*/) {\n          // Base profile\n          if (name == "restrict-qir<base-profile>")\n          {\n            RuleSet rule_set;\n\n            // Defining the mapping\n            auto factory = RuleFactory(rule_set);\n\n            factory.useStaticQuantumArrayAllocation();\n            factory.useStaticQuantumAllocation();\n            factory.useStaticResultAllocation();\n\n            factory.optimiseBranchQuatumOne();\n            //  factory.optimiseBranchQuatumZero();\n\n            factory.disableReferenceCounting();\n            factory.disableAliasCounting();\n            factory.disableStringSupport();\n\n            fpm.addPass(TransformationRulePass(std::move(rule_set)));\n            return true;\n          }\n\n          return false;\n        });\n      }};\n')])])]),a("p",[e._v("Transformations of the IR will happen on the basis of what rules are added to the rule set. The purpose of the factory is to make easy to add rules that serve a single purpose as well as making a basis for making rules unit testable.")]),e._v(" "),a("h2",{attrs:{id:"implementing-new-rules"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#implementing-new-rules"}},[e._v("#")]),e._v(" Implementing new rules")]),e._v(" "),a("p",[e._v("Implementing new rules consists of two steps: Defining a pattern that one wish to replace and implementing the corresponding replacement logic. Inside a factory member function, this look as follows:")]),e._v(" "),a("div",{staticClass:"language-c++ extra-class"},[a("pre",{pre:!0,attrs:{class:"language-text"}},[a("code",[e._v('  auto get_element =\n      Call("__quantum__rt__array_get_element_ptr_1d", "arrayName"_cap = _, "index"_cap = _);\n  auto cast_pattern = BitCast("getElement"_cap = get_element);\n  auto load_pattern = Load("cast"_cap = cast_pattern);\n\n  addRule({std::move(load_pattern), access_replacer});\n')])])]),a("p",[e._v("where "),a("code",[e._v("addRule")]),e._v(" adds the rule to the current rule set.")]),e._v(" "),a("h2",{attrs:{id:"capturing-patterns"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#capturing-patterns"}},[e._v("#")]),e._v(" Capturing patterns")]),e._v(" "),a("p",[e._v("The pattern defined in this snippet matches IR like:")]),e._v(" "),a("div",{staticClass:"language-c++ extra-class"},[a("pre",{pre:!0,attrs:{class:"language-text"}},[a("code",[e._v("  %0 = call i8* @__quantum__rt__array_get_element_ptr_1d(%Array* %leftPreshared, i64 0)\n  %1 = bitcast i8* %0 to %Qubit**\n  %2 = load %Qubit*, %Qubit** %1, align 8\n")])])]),a("p",[e._v("In the above rule, the first and a second argument of "),a("code",[e._v("__quantum__rt__array_get_element_ptr_1d")]),e._v(" is captured as "),a("code",[e._v("arrayName")]),e._v(" and "),a("code",[e._v("index")]),e._v(", respectively. Likewise, the bitcast instruction is captured as "),a("code",[e._v("cast")]),e._v(". Each of these captures will be available inside the replacement function "),a("code",[e._v("access_replacer")]),e._v(".")]),e._v(" "),a("h2",{attrs:{id:"implementing-replacement-logic"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#implementing-replacement-logic"}},[e._v("#")]),e._v(" Implementing replacement logic")]),e._v(" "),a("p",[e._v("After a positive match is found, the lead instruction alongside a IRBuilder, a capture table and a replacement table is passed to the replacement function. Here is an example on how one can access the captured variables to perform a transformation of the IR:")]),e._v(" "),a("div",{staticClass:"language-c++ extra-class"},[a("pre",{pre:!0,attrs:{class:"language-text"}},[a("code",[e._v('  auto access_replacer = [qubit_alloc_manager](Builder &builder, Value *val, Captures &cap,\n                                               Replacements &replacements) {\n    // ...\n    auto cst = llvm::dyn_cast<llvm::ConstantInt>(cap["index"]);\n    // ...\n    auto llvm_size = cst->getValue();\n    auto offset    = qubit_alloc_manager->getOffset(cap["arrayName"]->getName().str());\n\n    auto idx = llvm::APInt(llvm_size.getBitWidth(), llvm_size.getZExtValue() + offset);\n    auto new_index = llvm::ConstantInt::get(builder.getContext(), idx);\n    auto instr = new llvm::IntToPtrInst(new_index, ptr_type);\n    instr->takeName(val);\n\n    // Replacing the lead instruction with a the new instruction\n    replacements.push_back({llvm::dyn_cast<Instruction>(val), instr});\n\n    // Deleting the getelement and cast operations\n    replacements.push_back({llvm::dyn_cast<Instruction>(cap["getElement"]), nullptr});\n    replacements.push_back({llvm::dyn_cast<Instruction>(cap["cast"]), nullptr});\n\n    return true;\n  };\n')])])])])}),[],!1,null,null,null);t.default=s.exports}}]);