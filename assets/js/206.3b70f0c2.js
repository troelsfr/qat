(window.webpackJsonp=window.webpackJsonp||[]).push([[206],{588:function(t,e,a){"use strict";a.r(e);var r=a(54),i=Object(r.a)({},(function(){var t=this,e=t.$createElement,a=t._self._c||e;return a("ContentSlotsDistributor",{attrs:{"slot-key":t.$parent.slotKey}},[a("h1",{attrs:{id:"introduction-to-profiles"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#introduction-to-profiles"}},[t._v("#")]),t._v(" Introduction to profiles")]),t._v(" "),a("p",[t._v("In this document we discuss QIR profiles. A QIR profile describes a subset of the generic QIR functionality and conventions. It\nis anticipated that most usages of the QIR specification will need to only use a subset of it. These subsets\nmay further be subject to constraints such as how one allocate or acquire a qubit handle. We refer to such a subset with\nconstraints as a profile. For instance, it is likely that early versions of quantum hardware will have a limited\nset of classical instructions available. With this in mind, the vendor or user of said hardware would define a profile\nthat only contains a specified subset. One example of such a profile is the base profile,\nwhich only allows function calls and branching, but no arithmetic, classical memory, or classical registers.")]),t._v(" "),a("p",[t._v("The generation of QIR according to the spec with no constraints would typically be performed by the frontend. A couple\nof examples are Q# or OpenQASM 2.0/3.0. However, for the generated QIR to be practical it is necessary to reduce it using a profile\nwhich is compatible with the target platform:")]),t._v(" "),a("div",{staticClass:"language-text extra-class"},[a("pre",{pre:!0,attrs:{class:"language-text"}},[a("code",[t._v("┌──────────────────────┐\n│       Frontend       │\n└──────────────────────┘\n           │\n           │ QIR\n           ▼\n┌──────────────────────┐\n│  QIR Adaptor Tool    │ &lt;─────── QIR Profile\n└──────────────────────┘\n           │\n           │ Adapted QIR\n           ▼\n┌──────────────────────┐\n│       Backend        │\n└──────────────────────┘\n")])])]),a("p",[t._v("As an example, a hardware based quantum platform may only have support for sequential gates with no branching or ability for subroutines. Likewise, some quantum platforms only allow for a single measurement at the end of executing the pipeline of quantum gates. Profiles suppose to express these nuances and restrictions which are absent in the generic QIR.")]),t._v(" "),a("h2",{attrs:{id:"generic-qir-specification"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#generic-qir-specification"}},[t._v("#")]),t._v(" Generic QIR specification")]),t._v(" "),a("p",[t._v("See "),a("a",{attrs:{href:"https://github.com/microsoft/qsharp-language/tree/main/Specifications/QIR",target:"_blank",rel:"noopener noreferrer"}},[t._v("Quantum Intermediate Representation (QIR)"),a("OutboundLink")],1)]),t._v(" "),a("h2",{attrs:{id:"pipeline-profile"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#pipeline-profile"}},[t._v("#")]),t._v(" Pipeline profile")]),t._v(" "),a("p",[t._v("This profile assumes a quantum system where qubits and result registers fixed in availability. That is to say, that one target may have 25 qubits and 10 result registers.")]),t._v(" "),a("p",[t._v("The pipeline profile is the profile with the least classical logic available. It only supports "),a("a",{attrs:{href:"https://llvm.org/docs/LangRef.html#call-instruction",target:"_blank",rel:"noopener noreferrer"}},[a("code",[t._v("call")]),a("OutboundLink")],1),t._v(", "),a("a",{attrs:{href:"https://llvm.org/docs/LangRef.html#inttoptr-to-instruction",target:"_blank",rel:"noopener noreferrer"}},[a("code",[t._v("inttoptr")]),a("OutboundLink")],1),t._v(", 64-bit integers "),a("a",{attrs:{href:"https://llvm.org/docs/LangRef.html#integer-type",target:"_blank",rel:"noopener noreferrer"}},[a("code",[t._v("i64")]),a("OutboundLink")],1),t._v(", qubit ids "),a("a",{attrs:{href:"https://github.com/microsoft/qsharp-language/blob/main/Specifications/QIR/Data-Types.md#opaque-types",target:"_blank",rel:"noopener noreferrer"}},[a("code",[t._v("Qubit*")]),a("OutboundLink")],1),t._v(" and result ids "),a("code",[t._v("Result*")]),t._v(". It does not provide a runtime and only intrinsic quantum instructions are available to this profile. This profile is intended for client-host type infrastructure where a gate pipeline is uploaded to the client quantum system and executed one or more times. Measurements are always performed at the end of the execution and all available results. This profile only allows for defining a single function that takes no arguments and has no return type.")]),t._v(" "),a("p",[t._v("Available types")]),t._v(" "),a("table",[a("thead",[a("tr",[a("th",[t._v("Typename")]),t._v(" "),a("th",[t._v("Description")])])]),t._v(" "),a("tbody",[a("tr",[a("td",[t._v("Result")]),t._v(" "),a("td",[t._v("Used as pointer type within the ID for constant integers")])]),t._v(" "),a("tr",[a("td",[t._v("Qubit")]),t._v(" "),a("td",[t._v("Used as pointer type within the ID for constant integers")])])])]),t._v(" "),a("p",[t._v("As an example of how these types can be used:")]),t._v(" "),a("div",{staticClass:"language- extra-class"},[a("pre",{pre:!0,attrs:{class:"language-text"}},[a("code",[t._v("%0 = Qubit* inttoptr 1 to Qubit*\n")])])]),a("p",[t._v("which expresses that we store the handle to qubit with ID 1 in the variable "),a("code",[t._v("%0")]),t._v(". Result registers are referred to in a similar manner.")]),t._v(" "),a("h2",{attrs:{id:"base-profile"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#base-profile"}},[t._v("#")]),t._v(" Base Profile")]),t._v(" "),a("p",[t._v("The base profile is a slight advancement to the pipeline profile")]),t._v(" "),a("p",[t._v("Available types")]),t._v(" "),a("table",[a("thead",[a("tr",[a("th",[t._v("Typename")]),t._v(" "),a("th"),t._v(" "),a("th")])]),t._v(" "),a("tbody",[a("tr",[a("td",[t._v("Array")]),t._v(" "),a("td"),t._v(" "),a("td")]),t._v(" "),a("tr",[a("td",[t._v("Result")]),t._v(" "),a("td"),t._v(" "),a("td")]),t._v(" "),a("tr",[a("td",[t._v("Qubit")]),t._v(" "),a("td"),t._v(" "),a("td")])])]),t._v(" "),a("p",[t._v("Available quantum intrinsic functions")]),t._v(" "),a("table",[a("thead",[a("tr",[a("th"),t._v(" "),a("th"),t._v(" "),a("th")])]),t._v(" "),a("tbody",[a("tr",[a("td"),t._v(" "),a("td"),t._v(" "),a("td")]),t._v(" "),a("tr",[a("td"),t._v(" "),a("td"),t._v(" "),a("td")]),t._v(" "),a("tr",[a("td"),t._v(" "),a("td"),t._v(" "),a("td")])])]),t._v(" "),a("p",[t._v("Available runtime functions")]),t._v(" "),a("table",[a("thead",[a("tr",[a("th"),t._v(" "),a("th"),t._v(" "),a("th")])]),t._v(" "),a("tbody",[a("tr",[a("td"),t._v(" "),a("td"),t._v(" "),a("td")]),t._v(" "),a("tr",[a("td"),t._v(" "),a("td"),t._v(" "),a("td")]),t._v(" "),a("tr",[a("td"),t._v(" "),a("td"),t._v(" "),a("td")])])]),t._v(" "),a("p",[t._v("Available IR functionality")]),t._v(" "),a("table",[a("thead",[a("tr",[a("th"),t._v(" "),a("th"),t._v(" "),a("th")])]),t._v(" "),a("tbody",[a("tr",[a("td",[t._v("call")]),t._v(" "),a("td"),t._v(" "),a("td")]),t._v(" "),a("tr",[a("td",[t._v("ret")]),t._v(" "),a("td"),t._v(" "),a("td")]),t._v(" "),a("tr",[a("td"),t._v(" "),a("td"),t._v(" "),a("td")])])])])}),[],!1,null,null,null);e.default=i.exports}}]);