(window.webpackJsonp=window.webpackJsonp||[]).push([[195],{576:function(t,a,s){"use strict";s.r(a);var n=s(54),e=Object(n.a)({},(function(){var t=this,a=t.$createElement,s=t._self._c||a;return s("ContentSlotsDistributor",{attrs:{"slot-key":t.$parent.slotKey}},[s("h1",{attrs:{id:"shorthand-notation"}},[s("a",{staticClass:"header-anchor",attrs:{href:"#shorthand-notation"}},[t._v("#")]),t._v(" Shorthand Notation")]),t._v(" "),s("p",[s("a",{attrs:{href:"#detailed-description"}},[t._v("More...")])]),t._v(" "),s("h2",{attrs:{id:"functions"}},[s("a",{staticClass:"header-anchor",attrs:{href:"#functions"}},[t._v("#")]),t._v(" Functions")]),t._v(" "),s("table",[s("thead",[s("tr",[s("th"),t._v(" "),s("th",[t._v("Name")])])]),t._v(" "),s("tbody",[s("tr",[s("td"),t._v(" "),s("td",[s("strong",[s("RouterLink",{attrs:{to:"/Modules/group__shorthand_notation.html#function-capture"}},[t._v("Capture")])],1),t._v("(std::string const & name)"),s("br"),t._v("Explicit creation using string name constructor.")])]),t._v(" "),s("tr",[s("td",[t._v("IOperandPrototypePtr")]),t._v(" "),s("td",[s("strong",[s("RouterLink",{attrs:{to:"/Modules/group__shorthand_notation.html#function-operator="}},[t._v("operator=")])],1),t._v("(IOperandPrototypePtr const & other)")])]),t._v(" "),s("tr",[s("td",[t._v("template <typename... Args> "),s("br"),t._v("IOperandPrototypePtr")]),t._v(" "),s("td",[s("strong",[s("RouterLink",{attrs:{to:"/Modules/group__shorthand_notation.html#function-call"}},[t._v("call")])],1),t._v("(std::string const & name, Args... args)")])]),t._v(" "),s("tr",[s("td",[t._v("IOperandPrototypePtr")]),t._v(" "),s("td",[s("strong",[s("RouterLink",{attrs:{to:"/Modules/group__shorthand_notation.html#function-unnamedinvoke"}},[t._v("unnamedInvoke")])],1),t._v("()"),s("br"),t._v("Matches a invoke instruction.")])]),t._v(" "),s("tr",[s("td",[t._v("template <typename... Args> "),s("br"),t._v("IOperandPrototypePtr")]),t._v(" "),s("td",[s("strong",[s("RouterLink",{attrs:{to:"/Modules/group__shorthand_notation.html#function-phi"}},[t._v("phi")])],1),t._v("(Args... args)"),s("br"),t._v("Matches a phi node with N arguments.")])]),t._v(" "),s("tr",[s("td",[t._v("IOperandPrototypePtr")]),t._v(" "),s("td",[s("strong",[s("RouterLink",{attrs:{to:"/Modules/group__shorthand_notation.html#function-callbynameonly"}},[t._v("callByNameOnly")])],1),t._v("(std::string const & name)")])]),t._v(" "),s("tr",[s("td",[t._v("IOperandPrototypePtr")]),t._v(" "),s("td",[s("strong",[s("RouterLink",{attrs:{to:"/Modules/group__shorthand_notation.html#function-bitcast"}},[t._v("bitCast")])],1),t._v("(IOperandPrototypePtr const & arg)"),s("br"),t._v("Matches the llvm::BitCast instructruction.")])]),t._v(" "),s("tr",[s("td",[t._v("IOperandPrototypePtr")]),t._v(" "),s("td",[s("strong",[s("RouterLink",{attrs:{to:"/Modules/group__shorthand_notation.html#function-inttoptr"}},[t._v("intToPtr")])],1),t._v("(IOperandPrototypePtr const & arg)"),s("br"),t._v("Matches the llvm::IntToPtr instructruction.")])]),t._v(" "),s("tr",[s("td",[t._v("IOperandPrototypePtr")]),t._v(" "),s("td",[s("strong",[s("RouterLink",{attrs:{to:"/Modules/group__shorthand_notation.html#function-constint"}},[t._v("constInt")])],1),t._v("()"),s("br"),t._v("Matches the llvm::ConstantInt instructruction.")])]),t._v(" "),s("tr",[s("td",[t._v("IOperandPrototypePtr")]),t._v(" "),s("td",[s("strong",[s("RouterLink",{attrs:{to:"/Modules/group__shorthand_notation.html#function-branch"}},[t._v("branch")])],1),t._v("(IOperandPrototypePtr const & cond, IOperandPrototypePtr const & arg1, IOperandPrototypePtr const & arg2)"),s("br"),t._v("Matches a branch instruction given a condition and two arguments.")])]),t._v(" "),s("tr",[s("td",[t._v("IOperandPrototypePtr")]),t._v(" "),s("td",[s("strong",[s("RouterLink",{attrs:{to:"/Modules/group__shorthand_notation.html#function-switchop"}},[t._v("switchOp")])],1),t._v("(IOperandPrototypePtr const & cond, IOperandPrototypePtr const & arg1, IOperandPrototypePtr const & arg2)")])]),t._v(" "),s("tr",[s("td",[t._v("IOperandPrototypePtr")]),t._v(" "),s("td",[s("strong",[s("RouterLink",{attrs:{to:"/Modules/group__shorthand_notation.html#function-select"}},[t._v("select")])],1),t._v("(IOperandPrototypePtr const & cond, IOperandPrototypePtr const & arg1, IOperandPrototypePtr const & arg2)"),s("br"),t._v("Matches a select instruction given a condition and two arguments.")])]),t._v(" "),s("tr",[s("td",[t._v("IOperandPrototypePtr")]),t._v(" "),s("td",[s("strong",[s("RouterLink",{attrs:{to:"/Modules/group__shorthand_notation.html#function-load"}},[t._v("load")])],1),t._v("(IOperandPrototypePtr const & arg)"),s("br"),t._v("Matches a load instruction with one argument.")])]),t._v(" "),s("tr",[s("td",[t._v("IOperandPrototypePtr")]),t._v(" "),s("td",[s("strong",[s("RouterLink",{attrs:{to:"/Modules/group__shorthand_notation.html#function-store"}},[t._v("store")])],1),t._v("(IOperandPrototypePtr const & target, IOperandPrototypePtr const & value)")])]),t._v(" "),s("tr",[s("td",[t._v("IOperandPrototypePtr")]),t._v(" "),s("td",[s("strong",[s("RouterLink",{attrs:{to:"/Modules/group__shorthand_notation.html#function-basicblock"}},[t._v("basicBlock")])],1),t._v("()"),s("br"),t._v("Matches a load instruction with one argument.")])]),t._v(" "),s("tr",[s("td",[t._v("ReplacerFunction")]),t._v(" "),s("td",[s("strong",[s("RouterLink",{attrs:{to:"/Modules/group__shorthand_notation.html#function-deleteinstruction"}},[t._v("deleteInstruction")])],1),t._v("()")])]),t._v(" "),s("tr",[s("td",[t._v("Capture")]),t._v(" "),s("td",[s("strong",[s("RouterLink",{attrs:{to:'/Modules/group__shorthand_notation.html#function-operator""_cap'}},[t._v('operator""_cap')])],1),t._v("(char const * name, std::size_t )")])])])]),t._v(" "),s("h2",{attrs:{id:"attributes"}},[s("a",{staticClass:"header-anchor",attrs:{href:"#attributes"}},[t._v("#")]),t._v(" Attributes")]),t._v(" "),s("table",[s("thead",[s("tr",[s("th"),t._v(" "),s("th",[t._v("Name")])])]),t._v(" "),s("tbody",[s("tr",[s("td",[t._v("const std::shared_ptr< AnyPattern >")]),t._v(" "),s("td",[s("strong",[s("RouterLink",{attrs:{to:"/Modules/group__shorthand_notation.html#variable-_"}},[t._v("_")])],1)])])])]),t._v(" "),s("h2",{attrs:{id:"detailed-description"}},[s("a",{staticClass:"header-anchor",attrs:{href:"#detailed-description"}},[t._v("#")]),t._v(" Detailed Description")]),t._v(" "),s("p",[t._v("Shorthand notations are made to make it possible to match patterns in the QIR. This part of the library focuses on making it easy to express advance patterns in just a few lines and specify what parts of the IR is of interest to the replacer function. An example is following pattern")]),t._v(" "),s("div",{staticClass:"language-cpp extra-class"},[s("pre",{pre:!0,attrs:{class:"language-cpp"}},[s("code",[s("span",{pre:!0,attrs:{class:"token keyword"}},[t._v("auto")]),t._v(" get_one "),s("span",{pre:!0,attrs:{class:"token operator"}},[t._v("=")]),t._v(" "),s("span",{pre:!0,attrs:{class:"token function"}},[t._v("call")]),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("(")]),s("span",{pre:!0,attrs:{class:"token string"}},[t._v('"__quantum__rt__result_get_one"')]),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(")")]),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(";")]),t._v("\n"),s("span",{pre:!0,attrs:{class:"token function"}},[t._v("addRule")]),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("(")]),t._v("\n    "),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("{")]),s("span",{pre:!0,attrs:{class:"token function"}},[t._v("branch")]),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("(")]),s("span",{pre:!0,attrs:{class:"token string"}},[t._v('"cond"')]),t._v("_cap "),s("span",{pre:!0,attrs:{class:"token operator"}},[t._v("=")]),t._v(" "),s("span",{pre:!0,attrs:{class:"token function"}},[t._v("call")]),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("(")]),s("span",{pre:!0,attrs:{class:"token string"}},[t._v('"__quantum__rt__result_equal"')]),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(",")]),t._v(" "),s("span",{pre:!0,attrs:{class:"token string"}},[t._v('"result"')]),t._v("_cap "),s("span",{pre:!0,attrs:{class:"token operator"}},[t._v("=")]),t._v(" _"),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(",")]),t._v(" "),s("span",{pre:!0,attrs:{class:"token string"}},[t._v('"one"')]),t._v("_cap "),s("span",{pre:!0,attrs:{class:"token operator"}},[t._v("=")]),t._v("\n    get_one"),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(")")]),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(",")]),t._v(" _"),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(",")]),t._v(" _"),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(")")]),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(",")]),t._v("\n     replace_branch_positive"),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("}")]),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(")")]),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(";")]),t._v("\n")])])]),s("p",[t._v("which matches IRs of the form")]),t._v(" "),s("div",{staticClass:"language-cpp extra-class"},[s("pre",{pre:!0,attrs:{class:"language-cpp"}},[s("code",[s("span",{pre:!0,attrs:{class:"token operator"}},[t._v("%")]),s("span",{pre:!0,attrs:{class:"token number"}},[t._v("1")]),t._v(" "),s("span",{pre:!0,attrs:{class:"token operator"}},[t._v("=")]),t._v(" call "),s("span",{pre:!0,attrs:{class:"token operator"}},[t._v("%")]),t._v("Result"),s("span",{pre:!0,attrs:{class:"token operator"}},[t._v("*")]),t._v(" @"),s("span",{pre:!0,attrs:{class:"token function"}},[t._v("__quantum__rt__result_get_one")]),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("(")]),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(")")]),t._v("\n"),s("span",{pre:!0,attrs:{class:"token operator"}},[t._v("%")]),s("span",{pre:!0,attrs:{class:"token number"}},[t._v("2")]),t._v(" "),s("span",{pre:!0,attrs:{class:"token operator"}},[t._v("=")]),t._v(" call i1 @"),s("span",{pre:!0,attrs:{class:"token function"}},[t._v("__quantum__rt__result_equal")]),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("(")]),s("span",{pre:!0,attrs:{class:"token operator"}},[t._v("%")]),t._v("Result"),s("span",{pre:!0,attrs:{class:"token operator"}},[t._v("*")]),t._v(" "),s("span",{pre:!0,attrs:{class:"token operator"}},[t._v("%")]),s("span",{pre:!0,attrs:{class:"token number"}},[t._v("0")]),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(",")]),t._v(" "),s("span",{pre:!0,attrs:{class:"token operator"}},[t._v("%")]),t._v("Result"),s("span",{pre:!0,attrs:{class:"token operator"}},[t._v("*")]),t._v(" "),s("span",{pre:!0,attrs:{class:"token operator"}},[t._v("%")]),s("span",{pre:!0,attrs:{class:"token number"}},[t._v("1")]),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(")")]),t._v("\nbr i1 "),s("span",{pre:!0,attrs:{class:"token operator"}},[t._v("%")]),s("span",{pre:!0,attrs:{class:"token number"}},[t._v("2")]),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(",")]),t._v(" label "),s("span",{pre:!0,attrs:{class:"token operator"}},[t._v("%")]),t._v("then0__1"),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(",")]),t._v(" label "),s("span",{pre:!0,attrs:{class:"token operator"}},[t._v("%")]),t._v("continue__1\n")])])]),s("p",[t._v("The pattern futher specifies that as a successful match is obtained, a table capturing certain values must be created. In the above example, the table would contain three entries: "),s("code",[t._v("cond")]),t._v(", "),s("code",[t._v("result")]),t._v(" and "),s("code",[t._v("one")]),t._v(" each of which would point to a a llvm::Value* in the QIR. This allows the replacement function to easily manipulate the DAG in these three places (four if you include the main captured value which is always passed to the replacement function).")]),t._v(" "),s("p",[t._v("The module further has shorthand notation for often encountered patterns such as any operand.")]),t._v(" "),s("p",[t._v("The module also implements shorthand notation for common replacers.")]),t._v(" "),s("p",[t._v("Literals which ease the burned of capturing values and increase readibility of the code.")]),t._v(" "),s("h2",{attrs:{id:"functions-documentation"}},[s("a",{staticClass:"header-anchor",attrs:{href:"#functions-documentation"}},[t._v("#")]),t._v(" Functions Documentation")]),t._v(" "),s("h3",{attrs:{id:"function-capture"}},[s("a",{staticClass:"header-anchor",attrs:{href:"#function-capture"}},[t._v("#")]),t._v(" function Capture")]),t._v(" "),s("div",{staticClass:"language-cpp extra-class"},[s("pre",{pre:!0,attrs:{class:"language-cpp"}},[s("code",[s("span",{pre:!0,attrs:{class:"token keyword"}},[t._v("explicit")]),t._v(" "),s("span",{pre:!0,attrs:{class:"token function"}},[t._v("Capture")]),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("(")]),t._v("\n    std"),s("span",{pre:!0,attrs:{class:"token double-colon punctuation"}},[t._v("::")]),t._v("string "),s("span",{pre:!0,attrs:{class:"token keyword"}},[t._v("const")]),t._v(" "),s("span",{pre:!0,attrs:{class:"token operator"}},[t._v("&")]),t._v(" name\n"),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(")")]),t._v("\n")])])]),s("p",[t._v("Explicit creation using string name constructor.")]),t._v(" "),s("h3",{attrs:{id:"function-operator"}},[s("a",{staticClass:"header-anchor",attrs:{href:"#function-operator"}},[t._v("#")]),t._v(" function operator=")]),t._v(" "),s("div",{staticClass:"language-cpp extra-class"},[s("pre",{pre:!0,attrs:{class:"language-cpp"}},[s("code",[t._v("IOperandPrototypePtr "),s("span",{pre:!0,attrs:{class:"token keyword"}},[t._v("operator")]),s("span",{pre:!0,attrs:{class:"token operator"}},[t._v("=")]),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("(")]),t._v("\n    IOperandPrototypePtr "),s("span",{pre:!0,attrs:{class:"token keyword"}},[t._v("const")]),t._v(" "),s("span",{pre:!0,attrs:{class:"token operator"}},[t._v("&")]),t._v(" other\n"),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(")")]),t._v("\n")])])]),s("h3",{attrs:{id:"function-call"}},[s("a",{staticClass:"header-anchor",attrs:{href:"#function-call"}},[t._v("#")]),t._v(" function call")]),t._v(" "),s("div",{staticClass:"language-cpp extra-class"},[s("pre",{pre:!0,attrs:{class:"language-cpp"}},[s("code",[s("span",{pre:!0,attrs:{class:"token keyword"}},[t._v("template")]),t._v(" "),s("span",{pre:!0,attrs:{class:"token operator"}},[t._v("<")]),s("span",{pre:!0,attrs:{class:"token keyword"}},[t._v("typename")]),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(".")]),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(".")]),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(".")]),t._v(" Args"),s("span",{pre:!0,attrs:{class:"token operator"}},[t._v(">")]),t._v("\nIOperandPrototypePtr "),s("span",{pre:!0,attrs:{class:"token function"}},[t._v("call")]),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("(")]),t._v("\n    std"),s("span",{pre:!0,attrs:{class:"token double-colon punctuation"}},[t._v("::")]),t._v("string "),s("span",{pre:!0,attrs:{class:"token keyword"}},[t._v("const")]),t._v(" "),s("span",{pre:!0,attrs:{class:"token operator"}},[t._v("&")]),t._v(" name"),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(",")]),t._v("\n    Args"),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(".")]),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(".")]),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(".")]),t._v(" args\n"),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(")")]),t._v("\n")])])]),s("p",[t._v("Shorthand notations are made to make it possible to match patterns in the QIR. This part of the library focuses on making it easy to express advance patterns in just a few lines and specify what parts of the IR is of interest to the replacer function. An example is following pattern")]),t._v(" "),s("div",{staticClass:"language-cpp extra-class"},[s("pre",{pre:!0,attrs:{class:"language-cpp"}},[s("code",[s("span",{pre:!0,attrs:{class:"token keyword"}},[t._v("auto")]),t._v(" get_one "),s("span",{pre:!0,attrs:{class:"token operator"}},[t._v("=")]),t._v(" "),s("span",{pre:!0,attrs:{class:"token function"}},[t._v("call")]),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("(")]),s("span",{pre:!0,attrs:{class:"token string"}},[t._v('"__quantum__rt__result_get_one"')]),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(")")]),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(";")]),t._v("\n"),s("span",{pre:!0,attrs:{class:"token function"}},[t._v("addRule")]),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("(")]),t._v("\n    "),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("{")]),s("span",{pre:!0,attrs:{class:"token function"}},[t._v("branch")]),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("(")]),s("span",{pre:!0,attrs:{class:"token string"}},[t._v('"cond"')]),t._v("_cap "),s("span",{pre:!0,attrs:{class:"token operator"}},[t._v("=")]),t._v(" "),s("span",{pre:!0,attrs:{class:"token function"}},[t._v("call")]),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("(")]),s("span",{pre:!0,attrs:{class:"token string"}},[t._v('"__quantum__rt__result_equal"')]),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(",")]),t._v(" "),s("span",{pre:!0,attrs:{class:"token string"}},[t._v('"result"')]),t._v("_cap "),s("span",{pre:!0,attrs:{class:"token operator"}},[t._v("=")]),t._v(" _"),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(",")]),t._v(" "),s("span",{pre:!0,attrs:{class:"token string"}},[t._v('"one"')]),t._v("_cap "),s("span",{pre:!0,attrs:{class:"token operator"}},[t._v("=")]),t._v("\n    get_one"),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(")")]),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(",")]),t._v(" _"),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(",")]),t._v(" _"),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(")")]),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(",")]),t._v("\n     replace_branch_positive"),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("}")]),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(")")]),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(";")]),t._v("\n")])])]),s("p",[t._v("which matches IRs of the form")]),t._v(" "),s("div",{staticClass:"language-cpp extra-class"},[s("pre",{pre:!0,attrs:{class:"language-cpp"}},[s("code",[s("span",{pre:!0,attrs:{class:"token operator"}},[t._v("%")]),s("span",{pre:!0,attrs:{class:"token number"}},[t._v("1")]),t._v(" "),s("span",{pre:!0,attrs:{class:"token operator"}},[t._v("=")]),t._v(" call "),s("span",{pre:!0,attrs:{class:"token operator"}},[t._v("%")]),t._v("Result"),s("span",{pre:!0,attrs:{class:"token operator"}},[t._v("*")]),t._v(" @"),s("span",{pre:!0,attrs:{class:"token function"}},[t._v("__quantum__rt__result_get_one")]),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("(")]),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(")")]),t._v("\n"),s("span",{pre:!0,attrs:{class:"token operator"}},[t._v("%")]),s("span",{pre:!0,attrs:{class:"token number"}},[t._v("2")]),t._v(" "),s("span",{pre:!0,attrs:{class:"token operator"}},[t._v("=")]),t._v(" call i1 @"),s("span",{pre:!0,attrs:{class:"token function"}},[t._v("__quantum__rt__result_equal")]),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("(")]),s("span",{pre:!0,attrs:{class:"token operator"}},[t._v("%")]),t._v("Result"),s("span",{pre:!0,attrs:{class:"token operator"}},[t._v("*")]),t._v(" "),s("span",{pre:!0,attrs:{class:"token operator"}},[t._v("%")]),s("span",{pre:!0,attrs:{class:"token number"}},[t._v("0")]),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(",")]),t._v(" "),s("span",{pre:!0,attrs:{class:"token operator"}},[t._v("%")]),t._v("Result"),s("span",{pre:!0,attrs:{class:"token operator"}},[t._v("*")]),t._v(" "),s("span",{pre:!0,attrs:{class:"token operator"}},[t._v("%")]),s("span",{pre:!0,attrs:{class:"token number"}},[t._v("1")]),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(")")]),t._v("\nbr i1 "),s("span",{pre:!0,attrs:{class:"token operator"}},[t._v("%")]),s("span",{pre:!0,attrs:{class:"token number"}},[t._v("2")]),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(",")]),t._v(" label "),s("span",{pre:!0,attrs:{class:"token operator"}},[t._v("%")]),t._v("then0__1"),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(",")]),t._v(" label "),s("span",{pre:!0,attrs:{class:"token operator"}},[t._v("%")]),t._v("continue__1\n")])])]),s("p",[t._v("The pattern futher specifies that as a successful match is obtained, a table capturing certain values must be created. In the above example, the table would contain three entries: "),s("code",[t._v("cond")]),t._v(", "),s("code",[t._v("result")]),t._v(" and "),s("code",[t._v("one")]),t._v(" each of which would point to a a llvm::Value* in the QIR. This allows the replacement function to easily manipulate the DAG in these three places (four if you include the main captured value which is always passed to the replacement function). Shorthand notation to match an instruction for a function call. The resulting "),s("RouterLink",{attrs:{to:"/Classes/classmicrosoft_1_1quantum_1_1_i_operand_prototype.html"}},[t._v("IOperandPrototype")]),t._v(" matches a function call with arguments as specified by the arguments given. For instance,")],1),t._v(" "),s("div",{staticClass:"language-cpp extra-class"},[s("pre",{pre:!0,attrs:{class:"language-cpp"}},[s("code",[s("span",{pre:!0,attrs:{class:"token function"}},[t._v("addRule")]),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("(")]),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("{")]),s("span",{pre:!0,attrs:{class:"token function"}},[t._v("call")]),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("(")]),s("span",{pre:!0,attrs:{class:"token string"}},[t._v('"foo"')]),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(",")]),t._v(" _"),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(",")]),t._v(" _"),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(")")]),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(",")]),t._v(" "),s("span",{pre:!0,attrs:{class:"token function"}},[t._v("deleteInstruction")]),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("(")]),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(")")]),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("}")]),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(")")]),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(";")]),t._v("\n")])])]),s("p",[t._v("matches a call to the function "),s("code",[t._v("foo")]),t._v(" with exactly two arguments.")]),t._v(" "),s("p",[t._v("Shorthand notation to match an instruction for a function call. The resulting "),s("RouterLink",{attrs:{to:"/Classes/classmicrosoft_1_1quantum_1_1_i_operand_prototype.html"}},[t._v("IOperandPrototype")]),t._v(" matches a function call with arguments as specified by the arguments given. For instance,")],1),t._v(" "),s("div",{staticClass:"language-cpp extra-class"},[s("pre",{pre:!0,attrs:{class:"language-cpp"}},[s("code",[s("span",{pre:!0,attrs:{class:"token function"}},[t._v("addRule")]),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("(")]),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("{")]),s("span",{pre:!0,attrs:{class:"token function"}},[t._v("call")]),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("(")]),s("span",{pre:!0,attrs:{class:"token string"}},[t._v('"foo"')]),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(",")]),t._v(" _"),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(",")]),t._v(" _"),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(")")]),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(",")]),t._v(" "),s("span",{pre:!0,attrs:{class:"token function"}},[t._v("deleteInstruction")]),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("(")]),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(")")]),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("}")]),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(")")]),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(";")]),t._v("\n")])])]),s("p",[t._v("matches a call to the function "),s("code",[t._v("foo")]),t._v(" with exactly two arguments.")]),t._v(" "),s("h3",{attrs:{id:"function-unnamedinvoke"}},[s("a",{staticClass:"header-anchor",attrs:{href:"#function-unnamedinvoke"}},[t._v("#")]),t._v(" function unnamedInvoke")]),t._v(" "),s("div",{staticClass:"language-cpp extra-class"},[s("pre",{pre:!0,attrs:{class:"language-cpp"}},[s("code",[t._v("IOperandPrototypePtr "),s("span",{pre:!0,attrs:{class:"token function"}},[t._v("unnamedInvoke")]),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("(")]),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(")")]),t._v("\n")])])]),s("p",[t._v("Matches a invoke instruction.")]),t._v(" "),s("h3",{attrs:{id:"function-phi"}},[s("a",{staticClass:"header-anchor",attrs:{href:"#function-phi"}},[t._v("#")]),t._v(" function phi")]),t._v(" "),s("div",{staticClass:"language-cpp extra-class"},[s("pre",{pre:!0,attrs:{class:"language-cpp"}},[s("code",[s("span",{pre:!0,attrs:{class:"token keyword"}},[t._v("template")]),t._v(" "),s("span",{pre:!0,attrs:{class:"token operator"}},[t._v("<")]),s("span",{pre:!0,attrs:{class:"token keyword"}},[t._v("typename")]),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(".")]),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(".")]),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(".")]),t._v(" Args"),s("span",{pre:!0,attrs:{class:"token operator"}},[t._v(">")]),t._v("\nIOperandPrototypePtr "),s("span",{pre:!0,attrs:{class:"token function"}},[t._v("phi")]),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("(")]),t._v("\n    Args"),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(".")]),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(".")]),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(".")]),t._v(" args\n"),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(")")]),t._v("\n")])])]),s("p",[t._v("Matches a phi node with N arguments.")]),t._v(" "),s("h3",{attrs:{id:"function-callbynameonly"}},[s("a",{staticClass:"header-anchor",attrs:{href:"#function-callbynameonly"}},[t._v("#")]),t._v(" function callByNameOnly")]),t._v(" "),s("div",{staticClass:"language-cpp extra-class"},[s("pre",{pre:!0,attrs:{class:"language-cpp"}},[s("code",[t._v("IOperandPrototypePtr "),s("span",{pre:!0,attrs:{class:"token function"}},[t._v("callByNameOnly")]),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("(")]),t._v("\n    std"),s("span",{pre:!0,attrs:{class:"token double-colon punctuation"}},[t._v("::")]),t._v("string "),s("span",{pre:!0,attrs:{class:"token keyword"}},[t._v("const")]),t._v(" "),s("span",{pre:!0,attrs:{class:"token operator"}},[t._v("&")]),t._v(" name\n"),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(")")]),t._v("\n")])])]),s("p",[t._v("Shorthand notation to match an instruction with a specified name. Unlike call, this pattern matches by name only and ignore the arguments.")]),t._v(" "),s("div",{staticClass:"language-cpp extra-class"},[s("pre",{pre:!0,attrs:{class:"language-cpp"}},[s("code",[s("span",{pre:!0,attrs:{class:"token function"}},[t._v("addRule")]),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("(")]),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("{")]),s("span",{pre:!0,attrs:{class:"token function"}},[t._v("callByNameOnly")]),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("(")]),s("span",{pre:!0,attrs:{class:"token string"}},[t._v('"foo"')]),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(")")]),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(",")]),t._v(" "),s("span",{pre:!0,attrs:{class:"token function"}},[t._v("deleteInstruction")]),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("(")]),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(")")]),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("}")]),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(")")]),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(";")]),t._v("\n")])])]),s("p",[t._v("matches calls to the function "),s("code",[t._v("foo")]),t._v(" regardless of the number of arguments.")]),t._v(" "),s("h3",{attrs:{id:"function-bitcast"}},[s("a",{staticClass:"header-anchor",attrs:{href:"#function-bitcast"}},[t._v("#")]),t._v(" function bitCast")]),t._v(" "),s("div",{staticClass:"language-cpp extra-class"},[s("pre",{pre:!0,attrs:{class:"language-cpp"}},[s("code",[t._v("IOperandPrototypePtr "),s("span",{pre:!0,attrs:{class:"token function"}},[t._v("bitCast")]),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("(")]),t._v("\n    IOperandPrototypePtr "),s("span",{pre:!0,attrs:{class:"token keyword"}},[t._v("const")]),t._v(" "),s("span",{pre:!0,attrs:{class:"token operator"}},[t._v("&")]),t._v(" arg\n"),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(")")]),t._v("\n")])])]),s("p",[t._v("Matches the llvm::BitCast instructruction.")]),t._v(" "),s("h3",{attrs:{id:"function-inttoptr"}},[s("a",{staticClass:"header-anchor",attrs:{href:"#function-inttoptr"}},[t._v("#")]),t._v(" function intToPtr")]),t._v(" "),s("div",{staticClass:"language-cpp extra-class"},[s("pre",{pre:!0,attrs:{class:"language-cpp"}},[s("code",[t._v("IOperandPrototypePtr "),s("span",{pre:!0,attrs:{class:"token function"}},[t._v("intToPtr")]),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("(")]),t._v("\n    IOperandPrototypePtr "),s("span",{pre:!0,attrs:{class:"token keyword"}},[t._v("const")]),t._v(" "),s("span",{pre:!0,attrs:{class:"token operator"}},[t._v("&")]),t._v(" arg\n"),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(")")]),t._v("\n")])])]),s("p",[t._v("Matches the llvm::IntToPtr instructruction.")]),t._v(" "),s("h3",{attrs:{id:"function-constint"}},[s("a",{staticClass:"header-anchor",attrs:{href:"#function-constint"}},[t._v("#")]),t._v(" function constInt")]),t._v(" "),s("div",{staticClass:"language-cpp extra-class"},[s("pre",{pre:!0,attrs:{class:"language-cpp"}},[s("code",[t._v("IOperandPrototypePtr "),s("span",{pre:!0,attrs:{class:"token function"}},[t._v("constInt")]),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("(")]),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(")")]),t._v("\n")])])]),s("p",[t._v("Matches the llvm::ConstantInt instructruction.")]),t._v(" "),s("h3",{attrs:{id:"function-branch"}},[s("a",{staticClass:"header-anchor",attrs:{href:"#function-branch"}},[t._v("#")]),t._v(" function branch")]),t._v(" "),s("div",{staticClass:"language-cpp extra-class"},[s("pre",{pre:!0,attrs:{class:"language-cpp"}},[s("code",[t._v("IOperandPrototypePtr "),s("span",{pre:!0,attrs:{class:"token function"}},[t._v("branch")]),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("(")]),t._v("\n    IOperandPrototypePtr "),s("span",{pre:!0,attrs:{class:"token keyword"}},[t._v("const")]),t._v(" "),s("span",{pre:!0,attrs:{class:"token operator"}},[t._v("&")]),t._v(" cond"),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(",")]),t._v("\n    IOperandPrototypePtr "),s("span",{pre:!0,attrs:{class:"token keyword"}},[t._v("const")]),t._v(" "),s("span",{pre:!0,attrs:{class:"token operator"}},[t._v("&")]),t._v(" arg1"),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(",")]),t._v("\n    IOperandPrototypePtr "),s("span",{pre:!0,attrs:{class:"token keyword"}},[t._v("const")]),t._v(" "),s("span",{pre:!0,attrs:{class:"token operator"}},[t._v("&")]),t._v(" arg2\n"),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(")")]),t._v("\n")])])]),s("p",[t._v("Matches a branch instruction given a condition and two arguments.")]),t._v(" "),s("h3",{attrs:{id:"function-switchop"}},[s("a",{staticClass:"header-anchor",attrs:{href:"#function-switchop"}},[t._v("#")]),t._v(" function switchOp")]),t._v(" "),s("div",{staticClass:"language-cpp extra-class"},[s("pre",{pre:!0,attrs:{class:"language-cpp"}},[s("code",[t._v("IOperandPrototypePtr "),s("span",{pre:!0,attrs:{class:"token function"}},[t._v("switchOp")]),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("(")]),t._v("\n    IOperandPrototypePtr "),s("span",{pre:!0,attrs:{class:"token keyword"}},[t._v("const")]),t._v(" "),s("span",{pre:!0,attrs:{class:"token operator"}},[t._v("&")]),t._v(" cond"),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(",")]),t._v("\n    IOperandPrototypePtr "),s("span",{pre:!0,attrs:{class:"token keyword"}},[t._v("const")]),t._v(" "),s("span",{pre:!0,attrs:{class:"token operator"}},[t._v("&")]),t._v(" arg1"),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(",")]),t._v("\n    IOperandPrototypePtr "),s("span",{pre:!0,attrs:{class:"token keyword"}},[t._v("const")]),t._v(" "),s("span",{pre:!0,attrs:{class:"token operator"}},[t._v("&")]),t._v(" arg2\n"),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(")")]),t._v("\n")])])]),s("h3",{attrs:{id:"function-select"}},[s("a",{staticClass:"header-anchor",attrs:{href:"#function-select"}},[t._v("#")]),t._v(" function select")]),t._v(" "),s("div",{staticClass:"language-cpp extra-class"},[s("pre",{pre:!0,attrs:{class:"language-cpp"}},[s("code",[t._v("IOperandPrototypePtr "),s("span",{pre:!0,attrs:{class:"token function"}},[t._v("select")]),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("(")]),t._v("\n    IOperandPrototypePtr "),s("span",{pre:!0,attrs:{class:"token keyword"}},[t._v("const")]),t._v(" "),s("span",{pre:!0,attrs:{class:"token operator"}},[t._v("&")]),t._v(" cond"),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(",")]),t._v("\n    IOperandPrototypePtr "),s("span",{pre:!0,attrs:{class:"token keyword"}},[t._v("const")]),t._v(" "),s("span",{pre:!0,attrs:{class:"token operator"}},[t._v("&")]),t._v(" arg1"),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(",")]),t._v("\n    IOperandPrototypePtr "),s("span",{pre:!0,attrs:{class:"token keyword"}},[t._v("const")]),t._v(" "),s("span",{pre:!0,attrs:{class:"token operator"}},[t._v("&")]),t._v(" arg2\n"),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(")")]),t._v("\n")])])]),s("p",[t._v("Matches a select instruction given a condition and two arguments.")]),t._v(" "),s("h3",{attrs:{id:"function-load"}},[s("a",{staticClass:"header-anchor",attrs:{href:"#function-load"}},[t._v("#")]),t._v(" function load")]),t._v(" "),s("div",{staticClass:"language-cpp extra-class"},[s("pre",{pre:!0,attrs:{class:"language-cpp"}},[s("code",[t._v("IOperandPrototypePtr "),s("span",{pre:!0,attrs:{class:"token function"}},[t._v("load")]),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("(")]),t._v("\n    IOperandPrototypePtr "),s("span",{pre:!0,attrs:{class:"token keyword"}},[t._v("const")]),t._v(" "),s("span",{pre:!0,attrs:{class:"token operator"}},[t._v("&")]),t._v(" arg\n"),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(")")]),t._v("\n")])])]),s("p",[t._v("Matches a load instruction with one argument.")]),t._v(" "),s("h3",{attrs:{id:"function-store"}},[s("a",{staticClass:"header-anchor",attrs:{href:"#function-store"}},[t._v("#")]),t._v(" function store")]),t._v(" "),s("div",{staticClass:"language-cpp extra-class"},[s("pre",{pre:!0,attrs:{class:"language-cpp"}},[s("code",[t._v("IOperandPrototypePtr "),s("span",{pre:!0,attrs:{class:"token function"}},[t._v("store")]),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("(")]),t._v("\n    IOperandPrototypePtr "),s("span",{pre:!0,attrs:{class:"token keyword"}},[t._v("const")]),t._v(" "),s("span",{pre:!0,attrs:{class:"token operator"}},[t._v("&")]),t._v(" target"),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(",")]),t._v("\n    IOperandPrototypePtr "),s("span",{pre:!0,attrs:{class:"token keyword"}},[t._v("const")]),t._v(" "),s("span",{pre:!0,attrs:{class:"token operator"}},[t._v("&")]),t._v(" value\n"),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(")")]),t._v("\n")])])]),s("p",[t._v("Matches a store instruction with a target and a value.")]),t._v(" "),s("div",{staticClass:"language-cpp extra-class"},[s("pre",{pre:!0,attrs:{class:"language-cpp"}},[s("code",[s("span",{pre:!0,attrs:{class:"token function"}},[t._v("addRule")]),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("(")]),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("{")]),s("span",{pre:!0,attrs:{class:"token function"}},[t._v("store")]),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("(")]),s("span",{pre:!0,attrs:{class:"token string"}},[t._v('"target"')]),t._v("_cap "),s("span",{pre:!0,attrs:{class:"token operator"}},[t._v("=")]),t._v(" _"),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(",")]),t._v(" "),s("span",{pre:!0,attrs:{class:"token string"}},[t._v('"value"')]),t._v("_cap "),s("span",{pre:!0,attrs:{class:"token operator"}},[t._v("=")]),t._v(" _"),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(")")]),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(",")]),t._v(" replaceConstExpr"),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("}")]),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(")")]),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(";")]),t._v("\n")])])]),s("p",[t._v("where we want to match all store instructions and do not really care about how the target or value came about. In this case, we may want to capture the values to, for instance, make assignment at compile time.")]),t._v(" "),s("h3",{attrs:{id:"function-basicblock"}},[s("a",{staticClass:"header-anchor",attrs:{href:"#function-basicblock"}},[t._v("#")]),t._v(" function basicBlock")]),t._v(" "),s("div",{staticClass:"language-cpp extra-class"},[s("pre",{pre:!0,attrs:{class:"language-cpp"}},[s("code",[t._v("IOperandPrototypePtr "),s("span",{pre:!0,attrs:{class:"token function"}},[t._v("basicBlock")]),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("(")]),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(")")]),t._v("\n")])])]),s("p",[t._v("Matches a load instruction with one argument.")]),t._v(" "),s("h3",{attrs:{id:"function-deleteinstruction"}},[s("a",{staticClass:"header-anchor",attrs:{href:"#function-deleteinstruction"}},[t._v("#")]),t._v(" function deleteInstruction")]),t._v(" "),s("div",{staticClass:"language-cpp extra-class"},[s("pre",{pre:!0,attrs:{class:"language-cpp"}},[s("code",[t._v("ReplacerFunction "),s("span",{pre:!0,attrs:{class:"token function"}},[t._v("deleteInstruction")]),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("(")]),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(")")]),t._v("\n")])])]),s("p",[t._v("Shorthand notation to delete an instruction. If passed as the replacement function, this function generates a replacer that deletes the instruction. This is a shorthand notation for deleting an instruction that can be used with a custom rule when building a ruleset. This function can be used with shorthand notation for patterns as follows:")]),t._v(" "),s("div",{staticClass:"language-cpp extra-class"},[s("pre",{pre:!0,attrs:{class:"language-cpp"}},[s("code",[s("span",{pre:!0,attrs:{class:"token function"}},[t._v("addRule")]),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("(")]),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("{")]),s("span",{pre:!0,attrs:{class:"token function"}},[t._v("callByNameOnly")]),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("(")]),t._v("name"),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(")")]),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(",")]),t._v(" "),s("span",{pre:!0,attrs:{class:"token function"}},[t._v("deleteInstruction")]),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("(")]),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(")")]),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("}")]),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(")")]),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(";")]),t._v("\n")])])]),s("p",[t._v("to delete the instructions that calls functions with the name "),s("code",[t._v("name")]),t._v(".")]),t._v(" "),s("h3",{attrs:{id:"function-operator-cap"}},[s("a",{staticClass:"header-anchor",attrs:{href:"#function-operator-cap"}},[t._v("#")]),t._v(' function operator""_cap')]),t._v(" "),s("div",{staticClass:"language-cpp extra-class"},[s("pre",{pre:!0,attrs:{class:"language-cpp"}},[s("code",[t._v("Capture "),s("span",{pre:!0,attrs:{class:"token keyword"}},[t._v("operator")]),s("span",{pre:!0,attrs:{class:"token string"}},[t._v('""')]),s("span",{pre:!0,attrs:{class:"token function"}},[t._v("_cap")]),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("(")]),t._v("\n    "),s("span",{pre:!0,attrs:{class:"token keyword"}},[t._v("char")]),t._v(" "),s("span",{pre:!0,attrs:{class:"token keyword"}},[t._v("const")]),t._v(" "),s("span",{pre:!0,attrs:{class:"token operator"}},[t._v("*")]),t._v(" name"),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(",")]),t._v("\n    std"),s("span",{pre:!0,attrs:{class:"token double-colon punctuation"}},[t._v("::")]),t._v("size_t \n"),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(")")]),t._v("\n")])])]),s("p",[t._v("Literal for specifying the capture of a llvm::Value*. This literal calls the IOperandPrototype::enableCapture through the assignment of a IOperandPrototypePtr to the class "),s("RouterLink",{attrs:{to:"/Classes/classmicrosoft_1_1quantum_1_1notation_1_1_capture.html"}},[t._v("Capture")]),t._v(".")],1),t._v(" "),s("p",[t._v("As an example, one may want to match the pattern "),s("code",[t._v("foo(bar(baz(x)), y)")]),t._v(" and extract the variable "),s("code",[t._v("x")]),t._v(" to add meta data to it. The corresponding IR could look like:")]),t._v(" "),s("div",{staticClass:"language-cpp extra-class"},[s("pre",{pre:!0,attrs:{class:"language-cpp"}},[s("code",[s("span",{pre:!0,attrs:{class:"token operator"}},[t._v("%")]),s("span",{pre:!0,attrs:{class:"token number"}},[t._v("1")]),t._v(" "),s("span",{pre:!0,attrs:{class:"token operator"}},[t._v("=")]),t._v(" call "),s("span",{pre:!0,attrs:{class:"token operator"}},[t._v("%")]),t._v("Type"),s("span",{pre:!0,attrs:{class:"token operator"}},[t._v("*")]),t._v(" @"),s("span",{pre:!0,attrs:{class:"token function"}},[t._v("baz")]),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("(")]),s("span",{pre:!0,attrs:{class:"token operator"}},[t._v("%")]),t._v("Type"),s("span",{pre:!0,attrs:{class:"token operator"}},[t._v("*")]),t._v(" "),s("span",{pre:!0,attrs:{class:"token operator"}},[t._v("%")]),s("span",{pre:!0,attrs:{class:"token number"}},[t._v("0")]),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(")")]),t._v("\n"),s("span",{pre:!0,attrs:{class:"token operator"}},[t._v("%")]),s("span",{pre:!0,attrs:{class:"token number"}},[t._v("2")]),t._v(" "),s("span",{pre:!0,attrs:{class:"token operator"}},[t._v("=")]),t._v(" call "),s("span",{pre:!0,attrs:{class:"token operator"}},[t._v("%")]),t._v("Type"),s("span",{pre:!0,attrs:{class:"token operator"}},[t._v("*")]),t._v(" @"),s("span",{pre:!0,attrs:{class:"token function"}},[t._v("bar")]),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("(")]),s("span",{pre:!0,attrs:{class:"token operator"}},[t._v("%")]),t._v("Type"),s("span",{pre:!0,attrs:{class:"token operator"}},[t._v("*")]),t._v(" "),s("span",{pre:!0,attrs:{class:"token operator"}},[t._v("%")]),s("span",{pre:!0,attrs:{class:"token number"}},[t._v("1")]),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(")")]),t._v("\ncall "),s("span",{pre:!0,attrs:{class:"token keyword"}},[t._v("void")]),t._v(" @"),s("span",{pre:!0,attrs:{class:"token function"}},[t._v("foo")]),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("(")]),s("span",{pre:!0,attrs:{class:"token operator"}},[t._v("%")]),t._v("Type"),s("span",{pre:!0,attrs:{class:"token operator"}},[t._v("*")]),t._v(" "),s("span",{pre:!0,attrs:{class:"token operator"}},[t._v("%")]),s("span",{pre:!0,attrs:{class:"token number"}},[t._v("2")]),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(",")]),t._v(" "),s("span",{pre:!0,attrs:{class:"token operator"}},[t._v("%")]),t._v("Type"),s("span",{pre:!0,attrs:{class:"token operator"}},[t._v("*")]),t._v(" "),s("span",{pre:!0,attrs:{class:"token operator"}},[t._v("%")]),s("span",{pre:!0,attrs:{class:"token number"}},[t._v("3")]),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(")")]),t._v("\n")])])]),s("p",[t._v("To match this pattern, one would create the pattern "),s("code",[t._v('call("foo", call("bar", call("baz", "x"_cap = _)), _)')]),t._v(". This pattern would ensure that at the time where the replacer function is called, the value stored in "),s("code",[t._v("%0")]),t._v(" is captured under the name "),s("code",[t._v("x")]),t._v(".")]),t._v(" "),s("h2",{attrs:{id:"attributes-documentation"}},[s("a",{staticClass:"header-anchor",attrs:{href:"#attributes-documentation"}},[t._v("#")]),t._v(" Attributes Documentation")]),t._v(" "),s("h3",{attrs:{id:"variable"}},[s("a",{staticClass:"header-anchor",attrs:{href:"#variable"}},[t._v("#")]),t._v(" variable _")]),t._v(" "),s("div",{staticClass:"language-cpp extra-class"},[s("pre",{pre:!0,attrs:{class:"language-cpp"}},[s("code",[s("span",{pre:!0,attrs:{class:"token keyword"}},[t._v("static")]),t._v(" "),s("span",{pre:!0,attrs:{class:"token keyword"}},[t._v("const")]),t._v(" std"),s("span",{pre:!0,attrs:{class:"token double-colon punctuation"}},[t._v("::")]),t._v("shared_ptr"),s("span",{pre:!0,attrs:{class:"token operator"}},[t._v("<")]),t._v(" AnyPattern "),s("span",{pre:!0,attrs:{class:"token operator"}},[t._v(">")]),t._v(" _ "),s("span",{pre:!0,attrs:{class:"token operator"}},[t._v("=")]),t._v(" std"),s("span",{pre:!0,attrs:{class:"token double-colon punctuation"}},[t._v("::")]),s("span",{pre:!0,attrs:{class:"token generic-function"}},[s("span",{pre:!0,attrs:{class:"token function"}},[t._v("make_shared")]),s("span",{pre:!0,attrs:{class:"token generic class-name"}},[s("span",{pre:!0,attrs:{class:"token operator"}},[t._v("<")]),t._v("AnyPattern"),s("span",{pre:!0,attrs:{class:"token operator"}},[t._v(">")])])]),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("(")]),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(")")]),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(";")]),t._v("\n")])])]),s("p",[t._v("Shorthand notation for a wildcard which matches anything. This value is useful when for instance capturing the arguments of a function call where the origin of the value does not matter to the pattern.")]),t._v(" "),s("hr"),t._v(" "),s("p",[t._v("Updated on 18 November 2021 at 09:48:05 UTC")])])}),[],!1,null,null,null);a.default=e.exports}}]);